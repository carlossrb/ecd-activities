
\noindent \textcolor{COLOR1}{Questão 05)} Dado $n$ um número natural maior ou igual a 2, considere a matriz $A$ de tamanho
$n \times n$ cuja entrada na posição $i, j$ é $max{i, j}$. Na seguinte função foi implementado o método
de Gauss-Jordan para resolver sistemas lineares cuja matriz dos coeficientes é uma matriz $A$ da
forma anterior e os termos independentes são matrizes colunas com entradas inteiras quaisquer.
\\

\begin{lstlisting}
    import numpy as np


    def GaussJordan(A, b):
        b = np.array(b, dtype=float)
        A = np.array(A, dtype=float)
        Ab = np.column_stack((A, b))
        n = np.shape(Ab)[0]
        m = np.shape(Ab)[1]
        for i in range(0, n - 1, 1):
            if Ab[i, i] == 0:
                print("Divisao por zero")
                break
            for k in range(i + 1, n, 1):
                fator = Ab[k, i] / Ab[i, i]
                Ab[k, :] = Ab[k, :] - Ab[i, :] * fator
        for i in range(n - 1, -1, -1):
            for k in range(i - 1, -1, -1):
                fator = Ab[k, i] / Ab[i, i]
                Ab[k, :] = Ab[k, :] - Ab[i, :] * fator
            Ab[i, :] = Ab[i, :] / Ab[i, i]
        x = np.copy(Ab[:, m - 1])
        return x
\end{lstlisting}


Usando Python defina matrizes da forma acima e matrizes colunas $b$ com entradas inteiras aleatórias de tamanhos 5, 10, 15, 50, 100, 500, 1000 (especifique os comandos utilizados). Use as seguintes linhas para comparar o tempo de execução da função Gauss-Jordan (acima) e da função do numpy (linalg.solve) ao resolver cada sistema linear $AX = b$ definido anteriormente
\\

\begin{lstlisting}
    inicio = time.time()
    xgauss = GaussJordan(A,b)
    fim = time.time()
    print("Tempo de Gauss-Jordan:",fim - inicio)
    inicio = time.time()
    xnump = np.linalg.solve(A,b)
    fim = time.time()
    print("Tempo de numpy-solve:",fim - inicio)    
\end{lstlisting}

Qual a conclusão que você pode tirar deste experimento?